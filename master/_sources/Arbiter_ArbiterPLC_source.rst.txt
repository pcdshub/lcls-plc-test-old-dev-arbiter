

DUTs
----


GVLs
----


GVL
^^^

::

    VAR_GLOBAL
       {attribute 'pytmc' := '
        pv: ARBITER:K:Arbiter1
        '}
    	g_fbArbiter1	:	FB_Arbiter(25);

    	ReqBP	:	ST_BeamParams; //Currently the placeholder for the fully arbitrated BP set
    	
    	//Example implementation of the FFO
        (*
        {attribute 'pytmc' := '
        pv: ARBITER:K:FF1
        '} *)
    	{attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[PMPS_FFO]^Channel 1^Output'}
    	g_FastFaultOutput1	:	FB_HardwareFFOutput;
        
    	g_rTestingVelocity	:	LREAL := PMPS_GVL.VISIBLE_TEST_VELOCITY;
        
        AttemptReset    :   BOOL; // For testing
    END_VAR




GVL_CheckBounds
^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
        nTooLow : UDINT;
        nTooHigh : UDINT;
        nDivByZero : UDINT;
    END_VAR




POUs
----


CheckBounds
^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckBounds : DINT
    VAR_INPUT
    	index, lower, upper: DINT;
    END_VAR
    // User defined local variables
    VAR
        sMessageLow   : STRING := 'CheckBounds: Index too low (%d)';
        sMessageHigh  : STRING := 'CheckBounds: Index too high (%d)';
    END_VAR
    // Index too low
    IF index < lower THEN
        CheckBounds := lower;
        // Increase global counter
        GVL_CheckBounds.nTooLow := GVL_CheckBounds.nTooLow + 1;
        // Log message
        ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
                   msgFmtStr   := sMessageLow,
                   dintArg     := index);

    // Index too high
    ELSIF index > upper THEN
        CheckBounds := upper;
        // Increase global counter
        GVL_CheckBounds.nTooHigh := GVL_CheckBounds.nTooHigh + 1;
        // Log message
        ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
                   msgFmtStr   := sMessageHigh,
                   dintArg     := index);

    // Index OK
    ELSE 
        CheckBounds := index;
    END_IF
    {flow}

    END_FUNCTION


Related:
    * `GVL_CheckBounds`_


CheckRangeSigned
^^^^^^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckRangeSigned : DINT
    VAR_INPUT
    	value, lower, upper: DINT;
    END_VAR
    // Implicitly generated code : Only an Implementation suggestion

    IF (value < lower) THEN
    	CheckRangeSigned := lower;
    ELSIF(value > upper) THEN
    	CheckRangeSigned := upper;
    ELSE
    	CheckRangeSigned := value;
    END_IF
    {flow}

    END_FUNCTION




CheckRangeUnsigned
^^^^^^^^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckRangeUnsigned : UDINT
    VAR_INPUT
    	value, lower, upper: UDINT;
    END_VAR
    // Implicitly generated code : Only an Implementation suggestion
    {noflow}
    IF (value < lower) THEN
    	CheckRangeUnsigned := lower;
    ELSIF(value > upper) THEN
    	CheckRangeUnsigned := upper;
    ELSE
    	CheckRangeUnsigned := value;
    END_IF
    {flow}

    END_FUNCTION




Fast_Faults_Evaluate
^^^^^^^^^^^^^^^^^^^^

::

    PROGRAM Fast_Faults_Evaluate
    VAR
    END_VAR
    g_FastFaultOutput1.EvaluateOutput(i_xVeto:=PMPS_GVL.stCurrentBeamParameters.aStoppers[PMPS.L_Stopper.ST1]);

    END_PROGRAM




FB_eVSimulator
^^^^^^^^^^^^^^

::

    (* eV Simulator
    A. Wallace 2019-8-30

    Adds noise to the eV and changes eV position occasionally.
    *)
    FUNCTION_BLOCK FB_eVSimulator
    VAR_INPUT
    	NoiseLevel	:	REAL	:= 0; // eV Noise
    	ChangeTime : TIME := T#10S;
    END_VAR
    VAR_OUTPUT
    	eV	:	REAL := 300;
    END_VAR
    VAR
    	eVRange : REAL := 1600;
    	timer: TON;
    	eVRand	:	DRAND :=(Seed:=0);
    	NoiseRand : DRAND := (Seed:=0);
    END_VAR
    timer(in:=TRUE, PT:=ChangeTime);

    //Occasionally change eV
    IF timer.Q THEN
    	timer(in:=FALSE);
    	eVRand();
    	eV := LIMIT(0, eVRange*LREAL_TO_REAL(eVRand.Num), eVRange);
    END_IF

    // Noise generation
    NoiseRand();
    eV := eV + NoiseLevel*LREAL_TO_REAL(NoiseRand.Num);
    NoiseRand();
    eV := LIMIT(0, ev - NoiseLevel*LREAL_TO_REAL(NoiseRand.Num), eVRange);

    END_FUNCTION_BLOCK




FB_Hgvpu
^^^^^^^^

::

    FUNCTION_BLOCK FB_Hgvpu
    VAR_INPUT
    	
    END_VAR

    VAR_OUTPUT
    END_VAR


    VAR
        // From lcls-srv01: grep -e KDes  /u1/lcls/epics/ioc/data/ioc-undh-uc*/iocInfo/IOC.pvlist |sort

        {attribute 'pytmc' := 'pv: 24; link: 2450:'}
        fbSegment_24 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 25; link: 2550:'}
        fbSegment_25 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 26; link: 2650:'}
        fbSegment_26 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 27; link: 2750:'}
        fbSegment_27 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 29; link: 2950:'}
        fbSegment_29 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 30; link: 3050:'}
        fbSegment_30 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 31; link: 3150:'}
        fbSegment_31 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 32; link: 3250:'}
        fbSegment_32 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 33; link: 3350:'}
        fbSegment_33 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 34; link: 3450:'}
        fbSegment_34 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 35; link: 3550:'}
        fbSegment_35 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 36; link: 3650:'}
        fbSegment_36 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 37; link: 3750:'}
        fbSegment_37 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 38; link: 3850:'}
        fbSegment_38 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 39; link: 3950:'}
        fbSegment_39 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 40; link: 4050:'}
        fbSegment_40 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 41; link: 4150:'}
        fbSegment_41 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 42; link: 4250:'}
        fbSegment_42 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 43; link: 4350:'}
        fbSegment_43 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 44; link: 4450:'}
        fbSegment_44 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 45; link: 4550:'}
        fbSegment_45 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 46; link: 4650:'}
        fbSegment_46 : FB_UndulatorSegment;
        
        fbSegment : ARRAY [iLowBound..iHighBound] OF POINTER TO FB_UndulatorSegment;
        fbCurrentSegment : REFERENCE TO FB_UndulatorSegment;

        iIndex : UDINT;

        bInitialized : BOOL := FALSE;

    END_VAR

    VAR CONSTANT
        iLowBound  : UDINT := 24;
        iHighBound : UDINT := 46;
    END_VAR
    IF NOT bInitialized THEN

        fbSegment[24] := ADR(fbSegment_24);
        fbSegment[25] := ADR(fbSegment_25);
        fbSegment[26] := ADR(fbSegment_26);
        fbSegment[27] := ADR(fbSegment_27);
        fbSegment[28] := 0;
        fbSegment[29] := ADR(fbSegment_29);
        fbSegment[30] := ADR(fbSegment_30);
        fbSegment[31] := ADR(fbSegment_31);
        fbSegment[32] := ADR(fbSegment_32);
        fbSegment[33] := ADR(fbSegment_33);
        fbSegment[34] := ADR(fbSegment_34);
        fbSegment[35] := ADR(fbSegment_35);
        fbSegment[36] := ADR(fbSegment_36);
        fbSegment[37] := ADR(fbSegment_37);
        fbSegment[38] := ADR(fbSegment_38);
        fbSegment[39] := ADR(fbSegment_39);
        fbSegment[40] := ADR(fbSegment_40);
        fbSegment[41] := ADR(fbSegment_41);
        fbSegment[42] := ADR(fbSegment_42);
        fbSegment[43] := ADR(fbSegment_43);
        fbSegment[44] := ADR(fbSegment_44);
        fbSegment[45] := ADR(fbSegment_45);
        fbSegment[46] := ADR(fbSegment_46);

        bInitialized := TRUE;
    END_IF

    FOR iIndex := iLowBound TO iHighBound DO
        IF fbSegment[iIndex] <> 0 THEN
    		fbCurrentSegment REF= fbSegment[iIndex]^;
    		fbCurrentSegment();
        END_IF
    END_FOR

    END_FUNCTION_BLOCK


Related:
    * `FB_UndulatorSegment`_


FB_SXU
^^^^^^

::

    FUNCTION_BLOCK FB_SXU
    VAR_INPUT
    	
    END_VAR

    VAR_OUTPUT
    END_VAR



    VAR
        // From lcls-srv01: grep -e KDes  /u1/lcls/epics/ioc/data/sioc-unds-uc*/iocInfo/IOC.pvlist |sort


        {attribute 'pytmc' := 'pv: 26; link: 2650:'}
        fbSegment_26 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 27; link: 2750:'}
        fbSegment_27 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 28; link: 2850:'}
        fbSegment_28 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 29; link: 2950:'}
        fbSegment_29 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 30; link: 3050:'}
        fbSegment_30 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 31; link: 3150:'}
        fbSegment_31 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 32; link: 3250:'}
        fbSegment_32 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 33; link: 3350:'}
        fbSegment_33 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 34; link: 3450:'}
        fbSegment_34 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 36; link: 3650:'}
        fbSegment_36 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 37; link: 3750:'}
        fbSegment_37 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 38; link: 3850:'}
        fbSegment_38 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 39; link: 3950:'}
        fbSegment_39 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 40; link: 4050:'}
        fbSegment_40 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 41; link: 4150:'}
        fbSegment_41 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 42; link: 4250:'}
        fbSegment_42 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 43; link: 4350:'}
        fbSegment_43 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 44; link: 4450:'}
        fbSegment_44 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 45; link: 4550:'}
        fbSegment_45 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 46; link: 4650:'}
        fbSegment_46 : FB_UndulatorSegment;
        
        {attribute 'pytmc' := 'pv: 47; link: 4750:'}
        fbSegment_47 : FB_UndulatorSegment;
        


        fbSegment : ARRAY [iLowBound..iHighBound] OF POINTER TO FB_UndulatorSegment;
        fbCurrentSegment : REFERENCE TO FB_UndulatorSegment;

        iIndex : UDINT;

        bInitialized : BOOL := FALSE;

    END_VAR

    VAR CONSTANT
        iLowBound  : UDINT := 26;
        iHighBound : UDINT := 47;
    END_VAR
    IF NOT bInitialized THEN

        fbSegment[26] := ADR(fbSegment_26);
        fbSegment[27] := ADR(fbSegment_27);
        fbSegment[28] := ADR(fbSegment_28);
        fbSegment[29] := ADR(fbSegment_29);
        fbSegment[30] := ADR(fbSegment_30);
        fbSegment[31] := ADR(fbSegment_31);
        fbSegment[32] := ADR(fbSegment_32);
        fbSegment[33] := ADR(fbSegment_33);
        fbSegment[34] := ADR(fbSegment_34);
        fbSegment[35] := 0;
        fbSegment[36] := ADR(fbSegment_36);
        fbSegment[37] := ADR(fbSegment_37);
        fbSegment[38] := ADR(fbSegment_38);
        fbSegment[39] := ADR(fbSegment_39);
        fbSegment[40] := ADR(fbSegment_40);
        fbSegment[41] := ADR(fbSegment_41);
        fbSegment[42] := ADR(fbSegment_42);
        fbSegment[43] := ADR(fbSegment_43);
        fbSegment[44] := ADR(fbSegment_44);
        fbSegment[45] := ADR(fbSegment_45);
        fbSegment[46] := ADR(fbSegment_46);
        fbSegment[47] := ADR(fbSegment_47);

        bInitialized := TRUE;
    END_IF

    FOR iIndex := iLowBound TO iHighBound DO
        IF fbSegment[iIndex] <> 0 THEN
    		fbCurrentSegment REF= fbSegment[iIndex]^;
    		fbCurrentSegment();
        END_IF
    END_FOR

    END_FUNCTION_BLOCK


Related:
    * `FB_UndulatorSegment`_


FB_UndulatorSegment
^^^^^^^^^^^^^^^^^^^

::

    FUNCTION_BLOCK FB_UndulatorSegment
    VAR_INPUT
    END_VAR
    VAR_OUTPUT
    END_VAR
    VAR
    	{attribute 'pytmc' := '
    		pv: KDes
    		link: KDes
    	'}
    	fbKDesired : FB_LREALFromEPICS;

    	{attribute 'pytmc' := '
    		pv: KAct
    		link: KAct
    	'}
    	fbKActual : FB_LREALFromEPICS;

    END_VAR
    fbKDesired();
    fbKActual();

    END_FUNCTION_BLOCK




MachineSimulation
^^^^^^^^^^^^^^^^^

::

    PROGRAM MachineSimulation
    VAR
    	fbMachine	:	FB_MachineSimulator; //Simulates attenuator as well
    	fbeVSimulator : FB_eVSimulator := (NoiseLevel := 1);
    END_VAR
    // reV Simulator
    fbeVSimulator();

    // Machine simulator
    fbMachine(
    	i_stAssertedParams := ReqBP,
    	q_stMachineParams => PMPS_GVL.stCurrentBeamParameters,
    	i_xFault	:= NOT GVL.g_FastFaultOutput1.q_xFastFaultOut
    	);

    PMPS_GVL.stCurrentBeamParameters.neVRange := F_eVRangeCalculator(fbeVSimulator.eV, PMPS_GVL.stCurrentBeamParameters.neVRange);

    END_PROGRAM


Related:
    * `FB_eVSimulator`_
    * `GVL`_


MAIN
^^^^

::

    PROGRAM MAIN
    VAR
    	Initialize	:	BOOL := TRUE;
    	
    	AttemptReset : TON := (PT:=T#500ms);
        
        DisplayStats : FB_CXSetTextDisplayUSB := (nPort:=28928);
        fbFormat   : FB_FormatString;
        bError     : BOOL;
        nErrID     : UDINT;
        sOut       : T_MaxString;   
        
        {attribute 'pytmc' := '
    		pv: TEST:LOGHANDLER:
    	'}
    	fbLogHandler	: FB_LogHandler;
    	
    	fbEcatDiag : FB_EcatDiagWrapper;

    	{attribute 'pytmc' := '
    		pv: Arbiter:Link:HGVPU
    		link: USEG:UNDH:
    	'}
    	fbHgvpu : FB_Hgvpu;
    	
    	{attribute 'pytmc' := '
    		pv: Arbiter:Link:SXU
    		link: USEG:UNDS:
    	'}
    	fbSxu : FB_SXU;
    	
    END_VAR
    //Arbiter PLC

    IF Initialize THEN
    	Initialize := FALSE;
    END_IF

    MachineSimulation();
    		
    PMPS_Arbiter();

    AttemptReset(IN:=GVL.g_FastFaultOutput1.xOK, Q=>GVL.g_FastFaultOutput1.i_xReset);

    (*
    DisplayStats.bExecute S= NOT DisplayStats.bBusy AND NOT DisplayStats.bError;
    DisplayStats.bExecute R= DisplayStats.bBusy OR DisplayStats.bError;

    DisplayStats.sLine1 := 'PMPS-ARBITER-K';
    fbFormat(sFormat := 'Fast Faults: %d', arg1:=F_ULINT(PMPS_GVL.AccumulatedFF), sOut=>DisplayStats.sLine2, bError => bError, nErrID => nErrID ); 

    DisplayStats(eMode:=E_CX2100_DisplayModesWr.eCX2100_WriteLines);
    *)

    fbEcatDiag();
    fbLogHandler();

    END_PROGRAM

    ACTION Initialize:

    END_ACTION


Related:
    * `FB_Hgvpu`_
    * `FB_SXU`_
    * `GVL`_
    * `MachineSimulation`_
    * `PMPS_Arbiter`_


PMPS_Arbiter
^^^^^^^^^^^^

::

    PROGRAM PMPS_Arbiter
    VAR
    	
    	fbPhotonEnergyWatcher	:	FB_PhotonEnergyWatcher;
    	
    	fbMPSInterface	:	FB_BeamClassOutputs;
        
        fbCuInterface	:	FB_CTLS_Outputs;
    	
    	(* Subsystem requests use this FB and a pragma link to pass their requests to the arbiter.
    	The fb is called on each cycle and updates the arbiter with the current BP set requested 
    	from the subsystem PLC.*)
    	//<TODO> make this so it does input and output to the IF
    	{attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[SubSysPLC1]^IO Inputs^RequestedBP; 
                                    .o_CurrentBP:=TIIB[SubSysPLC1]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[SubSysPLC1]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[SubSysPLC1]^WcState^WcState;
                                    .i_TxPDOState:=TIIB[SubSysPLC1]^SYNC Inputs^TxPDO state;
                                    '}
    	fbSubSys1_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF0F);
    	
    	{attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[SubSysPLC2]^IO Inputs^RequestedBP;
                                    .i_xNewRequest:=TIIB[SubSysPLC2]^IO Inputs^xNewRequest; 
                                    .o_CurrentBP:=TIIB[SubSysPLC2]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[SubSysPLC2]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[SubSysPLC2]^WcState^WcState;
                                    .i_TxPDOState:=TIIB[SubSysPLC2]^SYNC Inputs^TxPDO state;
                                    .i_TxPDOToggle:=TIIB[SubSysPLC2]^SYNC Inputs^TxPDO toggle;
                                    '}
    	fbSubSys2_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF10);
        
        fbBPRequestor : FB_BPRequestor;
    	
    	AttemptReset : TON := (PT:=T#1s);
        
        anothervar : bool;
        testFF : FB_FastFault;
        
        logging_active : BOOL;
        cycle : INT;
        
        {attribute 'pytmc' := '
    		pv: @(P):PhotonEnergy
            link: ~
    	'}
        fPhotonEnergy : REAL;
        
        {attribute 'pytmc' := '
    		pv: @(P):PhotonEnergySeverity
            link: ~.SEVR
    	'}
        iPhotonEnergySeverity : INT;
    	
    END_VAR
    // Updating arbiter with subsystem requests.
    fbSubSys1_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);

    fbSubSys2_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);

    // Example with attenuator peel-off
    //////////////////////////////////

    // Beam parameter requestor
    fbBPRequestor(Arbiter:=GVL.g_fbArbiter1);

    // Request beam class
    fbMPSInterface(nBeamClass := 5);

    // Request Cu beam rate
    fbCuInterface(i_ArbiterBP := ReqBP);


    // Keep an eye on the photon energy
    fbPhotonEnergyWatcher(i_stCurrentBeamParams	:= PMPS_GVL.stCurrentBeamParameters,
    					i_stRequestedBeamParams := ReqBP,
    					io_fbFFHWO:= GVL.g_FastFaultOutput1,
                        i_xReset := GVL.AttemptReset);

    AttemptReset(IN:=fbPhotonEnergyWatcher.xPhotonEnergyWithinBounds, Q=>GVL.AttemptReset);

    // Trip a fast fault periodically
    testFF(io_fbFFHWO:= g_FastFaultOutput1);
    testFF.i_xOK := (cycle mod 1000) = 0;
    cycle := cycle + 1;

    g_FastFaultOutput1.EvaluateVetos();

    IF logging_active THEN
        g_FastFaultOutput1.ExecuteLogging();
    END_IF

    END_PROGRAM


Related:
    * `GVL`_

